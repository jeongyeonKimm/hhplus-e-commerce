# DB Lock

## 1. DB 락이란?
- 동시성 제어를 위해 DB에서 사용하는 메커니즘
- 여러 트랜잭션이 동일한 데이터에 접근할 때 데이터의 정합성(consistency)을 유지하도록 함

## 2. 락의 분류

### 2-1. 공유 락(Shared Lock, S-Lock)
- 읽기 허용, 쓰기 금지
- 여러 트랜잭션이 동시에 읽을 수 있음

### 2-2. 베타 락(Exclusive Lock, X-Lock)
- 읽기, 쓰기 모두 차단
- 트랜잭션 1개만 데이터에 접근 가능

### 2-3. 업데이트 락(Update Lock)
- 데이터를 수정하기 위해 베타 락을 걸기 전, 데드락을 방지하기 위해 사용
- `UPDATE` 쿼리의 `WHERE`가 실행되는 과정에서 적용

### 2-4. 내재 락(Intent Lock)
- 사용자가 요청한 범위에 대한 락을 걸 수 있는지 여부를 빠르게 파악하기 위해 사용되는 락
- 사용자가 row에 베타 락을 거는 시점에 해당 row의 상위 객체(페이지, 테이블 등)에 대한 내재 락을 걸어 락을 걸 수 있는지 파악

## 3. 낙관적 락(Optimistic Lock) vs. 비관적 락(Pessimistic Lock)

### 낙관적 락
- 충돌이 거의 없을 것이라는 의미 때문에 낙관적이라는 이름이 붙음
- 데이터를 읽을 때는 락을 걸지 않음
- 업데이트 시점에 버전 검사로 충돌 감지 -> 버전이 다르면 실패. 실패 시 예외 발생 & 재시도
- 장점
  - 락이 없어 성능이 좋음
  - 데드락이 발생하지 않음
- 단점
  - 충돌 시 예외 처리와 재시도 로직을 개발자가 직접 구현해야 하는 번거로움
  - 실시간성이 중요한 경우에 불리

### 비관적 락
- 충돌이 자주 발생할 것이라는 의미 때문에 비관적이라는 이름이 붙음
- 데이터를 조회하는 순간부터 실제로 락을 걸어 다른 트랜잭션의 접근 차단
- 장점
  - 충돌을 사전에 방지
  - 트랜잭션이 중요한 업무(결제, 재고 등)에 유리
  - 데이터 정합성 보장
- 단점
  - 별도의 락을 잡고 있기 때문에 성능 저하 우려
  - 락으로 인한 데드락 발생 가능

## 데드락(Deadlock)

- 두 트랜잭션이 서로 락이 풀리길 기다리는 상태에서 멈춰있는 것
- 예시
  - Tx 1이 데이터 A를 락
  - Tx 2이 데이터 B를 락
  - Tx 1은 B 락 시도, Tx 2는 A 락 시도
  - 서로 락 해제를 기다리고 있는 교착 상태 발생
- 해결 방법
  - 항상 동일한 순서로 자원 접근
  - 타임아웃을 설정하여 일정 시가 대기 후 중단
  - 락의 범위 최소화

## 주의사항
- 트랜잭션의 범위가 커지면 락의 유지 시간이 길어지면 성능 저하가 발생하기 때문에 트랜잭션의 범위는 가능한한 작게 설정
- 적절한 인덱스로 락의 성능 저하 방지

---
## E-Commerce 시나리오에 DB 락 적용

### 동시성 이슈가 발생 가능한 기능
1. 선착순 쿠폰 발급
2. 상품 재고 차감(주문)/복원(결제 실패)
3. 사용자 포인트 충전/사용

### 1. 선착순 쿠폰 발급
- 시나리오: 동일한 쿠폰을 여러 사용자가 동시에 발급 요청하거나 한 명의 사용자가 여러 번 발급 요청
- 예상되는 문제
  - 동일한 쿠폰을 여러 사용자가 동시에 발급 요청하면 쿠폰의 재고보다 많은 쿠폰이 발급될 수 있음
  - 하나의 쿠폰을 한 명의 사용자가 여러 번 발급 요청하면 중복 발급될 수 있음
- 분석: 쿠폰 재고의 경우 오차가 발생하면 안되기 때문에 데이터의 정합성이 중요하고, 선착순 이벤트의 경우 잦은 충돌 발생 예상
- 해결 방법: 비관적 락 적용
- 이유: 데이터의 정합성이 가장 강력하게 보장되고, DB 수준에서 락을 걸기 때문에 중복 발급 방지됨
- 한계점: 락이 걸려있는 동안 다른 트랜잭션이 대기하기 때문에 성능 저하 발생 가능
- 결과
  - 재고가 1개인 쿠폰을 2명의 사용자가 발급 요청한 경우
    - 낙관적 락 적용: 245ms
    <img width="1826" alt="Image" src="https://github.com/user-attachments/assets/49e36869-27ca-4276-aa05-129a9d415d94" />
    - 비관적 락 적용: 171ms 
    <img width="1829" alt="Image" src="https://github.com/user-attachments/assets/96571284-5f2c-4a5a-9f46-bcc089c5baff" />

### 2. 상품 재고 차감
- 시나리오: 동일한 상품을 여러 사용자가 동시에 주문하여 재고 차감 요청
- 예상되는 문제: 동일한 상품을 여러 사용자가 동시에 주문하여 재고 차감 요청을 하면 상품의 재고보다 많은 수량이 차감되어 상품 재고가 음수가 되는 상황이 발생할 수 있음
- 해결 방법: 비관적 락 + 상품 ID 기준으로 정렬
- 이유: 
  - 비관적 락은 데이터의 정합성이 가장 강력하게 보장되고, DB 수준에서 락을 걸기 때문에 중복 차감 방지됨
  - 상품 ID 기준으로 정렬하여 락 거는 순서를 일정하게 유지함으로써 데드락 예방
- 결과
  - 재고가 1인 상품을 2명의 사용자가 동시에 주문한 경우
    - 낙관적 락 적용: 291ms
    <img width="1826" alt="Image" src="https://github.com/user-attachments/assets/24b05df7-a3f6-40e6-bcb4-f26a20e3987d" />
    - 비관적 락 적용: 212ms
    <img width="1829" alt="Image" src="https://github.com/user-attachments/assets/f1e57b12-1f8f-4200-83f4-2fab56ae4d95" />

### 3. 상품 재고 복원
- 시나리오: 결제에 실패하여 상품의 재고 복원 요청
- 예상되는 문제: 여러 사용자가 동시에 결제에 실패하여 상품의 재고 복원 요청을 하면 복원해야 하는 재고의 누락 발생 가능
- 해결 방법: 비관적 락 적용
- 한계점: 재고를 숫자로서의 의미 뿐만 아니라 언제 누가 예약한 재고인지 관리하게 되면 의미가 달라짐. 실무에서 재고 관리를 안전하게 하기 위해서는 누구의 예약된 재고인지 파악 필요함. 따라서 재고를 분리하고 재고 사용 이력을 추적하여 안전한 재고 관리가 필요함.

### 4. 포인트 충전/사용
- 시나리오: 한 명의 사용자가 동일한 포인트 충전/사용 요청
- 예상되는 문제: 동일한 포인트 충전/사용 요청을 여러 번 하였을 때 포인트 충전과 사용이 여러 번 되어 데이터의 정합성이 깨지는 문제 발생
- 해결 방법: 비관적 락 적용 + 1초 이내에 같은 포인트 충전/사용 이력이 있는지 확인
- 결과
  - 한 명의 사용자가 동시에 여러 번 충전 요청을 하는 경우
    - 비관적 락 적용 + 충전 이력 조회
      <img width="1658" alt="Image" src="https://github.com/user-attachments/assets/d3fb50fa-0efc-4624-9565-6276425ef994" />
